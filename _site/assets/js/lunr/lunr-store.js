var store = [{
        "title": "1: Back to the Basics",
        "excerpt":"       About this Project   In this project, you will be making an LED light up! The first step will be to create the circuit from the schematic on your breadboard. After you have finished this part of the project, bring it to an officer to look at and they’ll ask you some questions about it. Then in part 2, you’ll solder your circuit to a perfboard. In summary, this project has two parts:     Breadboarding an LED circuit   Soldering the LED circuit onto a perfboard   Lecture Slides   Prerequisites      None   Skills Learned      Breadboarding   Ohm’s Law   Basic LED Circuitry   Soldering   Parts List                  Part       Quantity       Estimated Cost       Example Vendor                       Breadboard       1       $1.50       Amazon                 3.7V Battery       1       $7.95       Digikey                 JST Connector       1       $0.15       Digikey                 LED       1       $0.25       Digikey                 130 Ohm Resistor       1       $0.03       Digikey                 Perfboard       1       $4.95 (pack of 10)       Mouser           Total estimated cost: $10.38 per member If reusing Breadboard/3.7V Battery: $0.93 per member   Project Specification Part 1 (Breadboarding)   You will need the following materials for this part of the project.      Breadboard   3.7V Battery   JST Connector   LED   Resistor (calculate this)   You will need to calculate the resistor value on your own (hint: look at the slides).   Schematic   Please follow this schematic below to make your circuit. Remember the orientation of how you put in the LED in your breadboard and the two ways you can tell what the anode (+) and cathode(-) is on the LED.          Helpful Tips      To connect your battery to the breadboard, you will need something called a JST connector pictured below. The ridge at the end of the battery wires should fit into the JST pretty easily           Set up the circuit before you put the battery in   The red wire of the battery represents the 3.7 V power, while the black wire represents the 0 V battery   If you’re not sure about your circuit, show us before you put the battery in!   Don’t short your battery by connecting it with a wire   Don’t connect the same component’s two leads on the same row of the breadboard   DataSheets for LED   Remember, on the data sheet you are looking for the forward current/voltage needed to turn on the LED. You will have to filter through some specifications, but it should specifically say “Forward Current” and “Forward Voltage”. The column that says “Typ” means that this is the typical value for the component. Please use this value.     LED Datasheet   These values are what you will need to calculate the resistor value of the resistor you will need to pair with your LED.   Project Specification Part 2 (Soldering)   In part 2, you will basically “solder” an LED circuit onto a perfboard. You did all the prototyping on the breadboard to make sure your circuit was working. Now, you can permanently put it onto a perfboard. You will also be using the same exact components (resistor, LED, battery, etc.) that you used in part 1(breadboarding) for this part.   Basic Summary   Soldering is the process of joining two or more electronic parts together by melting solder around the connection. Solder is a metal alloy and when it cools it creates a strong electrical bond between the parts.   Here is a full tutorial on how to solder a circuit (LOOK AT THIS): Beginner’s Guide to Soldering   Make sure you ask an officer before you actually physically solder your circuit onto the perfboard!   Helpful Tips      Try not to use all the space on your perfboard, by keeping your circuit in a compact corner. You don’t want to do more work and solder the entire area of the board.   The soldering iron is very hot, so don’t touch the tip of the iron with your bare hands…   Remember to turn off the iron when you are done   Don’t leave a mess at the ironing station   Project Completion: Show your fully soldered LED circuit.   Checkoff Questions  Here are some questions you can use to test understanding of the concepts involved in part 1 of this project before moving on to part 2:             How do you determine the polarity (+ side vs. - side) of an LED?          Leg length              Anode (+): Longer Leg       Cathode (-): Shorter Leg                 Bulb Shape              Anode (+): Round       Cathode (-): Short                 Interior Metal Piece              Anode(+): Thin       Cathode (-): Fat       Didn’t go over this one in lecture, so just tell them this if they didn’t know                         Which side of the LED connects to the + terminal of the battery?                LED Anode (+)               Why do we need a resistor in our circuit? What would happen if we didn’t?            We need it to keep the current under the LED’s maximum current rating       We risk burning out the LED, or creating a short circuit           How do we pick a Resistor for the circuit?            Subtract LED operating voltage from Battery voltage       Divide by LED max current rating to get min resistance value       Note: There are multiple ways to do this. As long as KVL and Ohm’s Law are used, it’s ok!           Walk me through how you plan on soldering            Have a plan! Draw out a schematic       Turn on soldering station (650 F)       Wait for soldering station light to start blinking       Turn on exhaust       Use clamps/helping hands       Unplug batteries!       After: clean up, turn off fan and soldering station, wash hands!          ","categories": [],
        "tags": [],
        "url": "/projects/1-back-to-the-basics/",
        "teaser": "/assets/images/led-breadboard.jpg"
      },{
        "title": "2: Debugging",
        "excerpt":"       About this Project   You will need to come into the lab personally to debug 2 soldered circuits and 1 breadboarded circuit and get checked off by an officer who will ask you what is wrong with the circuits. You will apply what you learned from the lecture slides about what NOT to do and how to debug circuits. You will not be building anything in this project, but these debugging skills are essential for future projects when you have to debug your own circuits. Often times, we might think a circuit behaves one way, but in reality, it might behave a different way.   Lecture Slides   Prerequisites      1: Back to the Basics   Helpful Tips      Check if any components are shorted (i.e. is there a wire across the component)   Check if any components are open, meaning they aren’t connected to anything   Use the DMM continuity test for the soldered perfboard circuits to check for the shorted and open parts   Potential Buggy circuits   It is up to the project leads to create buggy circuits for project members to test. The buggy circuits should require members to measure both voltage and continuity using a multimeter. Some possible buggy circuits could be:      Perfboard circuit with discontinuity in solder trace, use continuity measurement   Breadboard circuit with short, use continuity measurement   LED circuit being powered by dead battery, use voltage measurement and inspect resistor   LED circuit that is not lighting up because the resistor is too large, use voltage measurement   LED circuit with a backwards LED, use voltage measurement and inspect LED  ","categories": [],
        "tags": [],
        "url": "/projects/2-debugging/",
        "teaser": "/assets/images/debugging.jpg"
      },{
        "title": "3: Integrated Circuits",
        "excerpt":"       About This Project   Part 1   In this project, you will be making an LED blink using an integrated circuit(IC), more specifically the 555 timer! We will treat the 555 timer as a black box, in the sense that we aren’t too concerned about the internal workings of the timer. We are more interested in what inputs we can use to get the desired output to make your LED blink at the rate you want. You will have to breadboard and solder this circuit for this project.   Part 2   In this project, you will be making a “piano” speaker that can play certain notes by pressing push buttons and using the 555 timer! In this part, you will have to both breadboard and solder onto a perfboard to get checked off.   Lecture Slides   Prerequisites      1: Back to the Basics   Skills Learned      Breadboarding   555 Timer Circuitry   Soldering   Parts List                  Part       Quantity       Estimated Cost Each       Example Vendor                       Breadboard       1       $1.50       Amazon                 Perfboard       2       $4.95 (pack of 10)       Mouser                 3.7V Battery       1       $7.95       Digikey                 JST Connector       2       $0.15       Digikey                 555 Timer       1       $0.45       Mouser                 8 Pin Dip Socket       2       $0.18       Digikey                 LED       1       $0.25       Digikey                 0.1 uF Capacitor       2       $0.24       Digikey                 68 uF Capacitor       1       $1.02       Digikey                 130 Ohm Resistor       1       $0.03       Digikey                 10 kOhm Resistor       2       $0.10       Digikey                 2.7 kOhm Resistor       3       $0.10       Digikey                 Speaker       1       $1.01       Digikey                 Tactile Switch (Push Button)       3       $0.11       Digikey           Total estimated cost: $15.17 per member If reusing Breadboard/3.7V Battery: $5.72 per member   Project Specification Part 1 (Make an LED Blink)   Input:      Components: R1,R2, or C2   Background: In order to change the rate that the LED blinks, we can change either R1,R2, or C2. If we want to change the time on given by Ton = 0.69 _ C2 _ (R1+R2), we can adjust R1, R2, or C2. If we wanted to change the time off given by Toff = 0.69 _ C2 _ R1, we would change the value of C2 or R1.   In this project, just use the resistor and capacitor values in the schematic above. You can play with the rate of the LED’s blink on your own time by changing C1,R1, or R2. Output:   Pins: Pin 3 and GND   Output wave: Square wave           The output in this project will go to your LED. The anode (+) leg of the LED will be connected to Pin 3 (OUT) and the cathode (-) of the LED is connected to GND. The output waveform is a square wave in the sense that voltage will either be HIGH (when your LED is on) or LOW (when your LED is off), but not in between and thus your LED will start to blink! This wave will continue infinitely until you remove the power source.   Parts Needed      A Breadboard   A Perfboard   A JST Connector   3.7V Battery   555 Timer   8 Pin dip socket   An LED   A resistor in series with the LED whose value you calculated from the Turn on LED project   Two 10kOhm resistors for R1 and R2   A 0.1uF capacitor for C1 connected to Pin 5 (CV = Control Voltage)   A 68uF capacitor for C2 connected to Pin 6 and GND   Some motivation   Schematic   NOTE: Although it says 0.01uF for C1 in the schematic, use 0.1uF instead          Part a: Breadboard   Create the schematic on your breadboard. Make sure you build your circuit before you plug in your battery connected to the JST connector. You should see your LED start to blink if it is working properly!   Part b: Soldering   Solder the circuit onto a perfboard. It will be more difficult than Project 1, so you will have to be very careful. You will also be able to ONLY use ONE WIRE at most for the soldering portion. We recommend you trace out the circuit with a pen/ sharpie onto the perfboard before you actually solder so you know what you are doing. This will give you a lot more practice on soldering and by the end of it, hopefully you will feel more comfortable doing it! Please ask for help if you need it!   One final note: DO NOT SOLDER THE 555 TIMER!! USE AN 8 PIN DIP SOCKET INSTEAD!!   Helpful Tips (READ THIS)   Place your 555 timer on the bridge between the middle columns of the breadboard. If you placed it so that horizontal pins are on the same row, you will basically short your battery. The top image is what you SHOULD do. The bottom image is what you SHOULD NOT do and since row 9 is connected the battery and ground pins will be connected.         Do This          Don't Do This    The intersection of lines may look confusing at first, but if the intersection doesn’t have a red dot, then those two pins aren’t connected. If they do have a red dot, they are connected. For example, Pin 2 and Pin 6 are connected/ share the same node since there is a red dot where their wires on the schematic meet. Another example would be looking at the bottom. You can see how the cathode (-) of the LED, Pin 1(GND), C1, and C2 are connected to ground and essentially “meet” at the same spot or share the same node, which is ground.   The output voltage for the OUT pin will be slightly less than the input voltage from your battery. This means that whatever resistor you used for the previous project will still work for this project. This will be the value for R3.   Project Specification Part 2 (555 Piano with a Speaker)   This part is very similar to Part 1 where you made an LED blink, but the output is now a speaker and the input is controlled by the push buttons which correspond to a certain resistance between Pin 6 and Pin 7.   Input:      Pin 7 and Pin 6   We knew we could change the rate of the LED blinking by changing either R1, R2, or C1. We are going to choose R2 which is the resistance between Pins 6 and 7 to vary from the previous schematic so that we could either increase or decrease the output frequency.   As you can see when S1 is pressed, current will flow through only the first 2.7kOhm resistor and bypass the other 2.7kOhm resistors since those branches are “open”. Thus, the equivalent resistance between Pin 9 and Pin 7 is 2.7kOhms.   When S2 is pressed, current will flow through the first two 2.7kohm resistors and bypass the third resistor. Since those two resistors are in series, they will add up to 5.4kOhms. Output:   Pins: Pin 3 and Pin 1(GND)   The speaker will be connected to the output pin or Pin 3 and connected back to ground. When you press on any of the push buttons, it will play a certain note (frequency).   Remember, a larger resistance for R2 means that the period of the square wave output is larger. A larger period means we have a lower frequency since T= 1/f → f=1/T. Thus the note that the speaker will play will be low. When there is a lower resistance, we have a smaller period and thus a higher frequency.            HIGHER RESISTANCE = LOWER FREQUENCY       LOWER RESISTANCE = HIGHER FREQUENCY                  Parts Needed      A Breadboard   A Perfboard   A JST Connector   3.7V Battery   555 Timer   3 Push Buttons   8 Pin dip socket   A Speaker   (1) 10kOhm resistors for R1 and R2   (3) 2.7kOhm resistors to use as resistance between Pin 6 and Pin 7   A 0.1uF capacitor for C1 connected to Pin 5 (CV = Control Voltage)   Some motivation   You should have all the parts from Part 1 except the pushbuttons and 2.7kOhm resistors. You will also need another 8 pin dip socket since you will be soldering for this part as well.   Part A: Breadboard   First, make sure to break off your speaker wires and resolder them with better wires that you strip yourself! If you don’t, you’re gonna have a bad time… Use the wire strippers in the lab and if you don’t know how to use it, feel free to ask any officer.   Create the schematic on your breadboard. Make sure you build your circuit before you plug in your battery connected to the JST connector. You should hear your speaker play a note when you press a push button.   Part B: Soldering   Make sure you Solder the circuit onto a perfboard. It will be more difficult than Project 1, so you will have to be very careful. You will also be able to ONLY use ONE WIRE at most for the soldering portion. We recommend you trace out the circuit with a pen/ sharpie onto the perfboard before you actually solder so you know what you are doing. This will give you a lot more practice on soldering and by the end of it, hopefully you will feel more comfortable doing it! Please ask for help if you need it!   Helpful Tips      If you don’t have anything connected between pins 6 and 7, the speaker will not turn on!   Look at nodes of the schematic and look at the components that are connected to it so that building the circuit on your breadboard is easier   Checkoff Questions   Here are some questions you can use to test understanding of the concepts involved in this project:   Part 1      What happens when you change the value of the 68 uF capacitor? (ie is the capacitance directly or inversely proportional to the blinking rate of the circuit?)            The capacitance is inversely proportional to the blinking rate. That means that as you get a higher capacitance, the time it takes to charge increases, blinking less frequently.           How do you tell which pins are which on the 555 timer?            Find the notch or dot on the IC, which shows you which pin is #1, then the pins are numbered counter-clockwise.           What is the purpose of the 0.1 uF capacitor?            Removes fluctuations (noise) in the supply voltage           You can use this schematic for reference to make sure they are doing their circuiting right:          Part 2      Why do you need three resistors for this part of the project?            Need 3 to make sure that there are 3 distinct pitches, because the frequency is related to the resistance           What happens when all 3 buttons are pressed? This is equivalent to pressing which button?            It’s equivalent to pressing only the first button (lowest resistance option). This is because the other two branches will be shorted.           Common Mistakes: If you hear a high pitched sound, 555 timer is broken  ","categories": [],
        "tags": [],
        "url": "/projects/3-integrated-circuits/",
        "teaser": "/assets/images/555-timer.jpg"
      },{
        "title": "4: Microcontrollers",
        "excerpt":"       About this Project   In this project, you will be working with microcontrollers which is just a fancy word for a small programmable computer that can coordinate different input/output functions in your circuit. The different components that will be attached to the microcontroller include a potentiometer(input) used as a voltage divider and an LED(output) that will change blinking frequency as you turn the potentiometer knob. This project will fuse both your knowledge on circuits and coding to make a really cool project!   Lecture Slides   Prerequisites      1: Back to the Basics   Skills Learned      Voltage Divider Circuit   Potentiometer   Choosing Arduino Pins   Arduino Programming   Parts List                  Part       Quantity       Estimated Cost       Example Vendor                       Breadboard       1       $1.50       Amazon                 Potentiometer       1       $0.95       Adafruit                 LED       1       $0.25       Digikey                 130 Ohm Resistor       1       $0.03       Digikey                 Arduino Nano       1       $4.00       Amazon                 Mini USB Cable       1       $2.00       Mouser           Total estimated cost: $8.73 per member If reusing Breadboard/Arduino/MiniUSB: $1.23 per member   Background   Voltage Dividers      A voltage divider is a circuit that consists of 2 resistors R1 and R2, and an input voltage Vin.   Vout is a measurement across the resistor closest to GND (R2) and its value depends on the ratio of R1 and R2.   Using Ohm’s Law (V=IR), we can determine the exact value of Vout            Equivalent Resistance Req = R1 + R2 (add when resistors are in series)       Vin = I * Req                    We can rearrange the equation to get: I = Vin/Req = Vin/(R1 + R2)                       Vout = V2 = I _ R2 _ We can plug in I found previously into this equation since current through R1 has the same value as R2 to get: Vout = Vin * (R2/(R1+R2))                               Potentiometers      All potentiometers have a total resistance associated with it and in this project, we have a 10K Ohm one. A potentiometer splits this 10K resistance into 2 resistances R1 and R2, whose values depend on how much the knob of a potentiometer is turned. See figure 2.   You can think of a potentiometer as a variable voltage divider because there are two resistances involved. By turning the potentiometer knob (wiper), the ratio of the 2 resistances in the potentiometer will change and thus Vout will also change.   There are 3 terminals, and the outermost terminals (1 and 3 in the figure below) are connected to either GND or VCC. The middle terminal(T2) should be connected to an INPUT pin on the Arduino since we want to READ the voltage of the potentiometer at that pin with respect to GND. The voltage you would be reading if looking at Figure 2 is the Vout or the voltage across R2. This setup will create a voltage divider circuit, where you will be able to change R1 and R2 by turning the knob.   NEVER CONNECT THE MIDDLE TERMINAL TO GND OR VCC            If you turn the knob all the way to the left so that R2 is 0 Ohms (no resistance) in the example below and then connect the output terminal to VCC, there will be a short from VCC to GND and your Arduino will fry/smoke/break which is NOT GOOD!       The same thing will happen if you turn the knob all the way to the right so that R1 has no resistance and connect the middle terminal to GND so that there is also a short from VCC to GND.       Always check this before doing anything else.                 Physical potentiometer and its 3 terminals         Symbolic representation of a potentiometer as 2 variable resistances    The Arduino Nano’s Pins      There are 3 types of programmable pins on the Arduino, but we will only focus on the first two types for this project. The pins can either read a voltage value or output a voltage.            Digital INPUT/OUTPUT pins                    These are labelled with the letter “D” on the Arduino Nano.           The digital pins will use a HIGH or LOW voltage to read/output. HIGH for the Arduino Nano equates to 5V and LOW is 0V. For the project, we want to have our LED turn completely ON/OFF instead of gradually dimming/becoming brighter, so we connect the LED to a digital OUTPUT pin.           Input: The pin will read either a HIGH(1) or LOW(0) voltage           Output: The pin will output either a HIGH(1) or LOW(0) voltage                       Analog INPUT pins                    These pins are labelled with the prefix letter “A” on the Arduino Nano.           Analog input pins will map a voltage between 0V and 5V to a digital number from 0-1023.           Note(not necessary to know): There are 1024 total digital values that can be represented because the Arduino uses a 10 bit ADC(analog to digital converter), meaning there are 2^10 = 1024 values that 10 bits can represent.           In this project, we want to connect the middle pin of the potentiometer to an analog input pin since we want to change the LED’s blinking frequency AS we are turning the potentiometer knob and can do so using a range of input values.                       Digital PWM OUTPUT pins                    To output an analog-like signal, PWM(pulse width modulation) pins are used. More on this in later projects. This is not used in this project.                                     The Arduino IDE      The Arduino Integrated Development Environment (IDE) uses syntax that is very similar to C++   The concepts that will be applicable when coding in the Arduino IDE are:            declaring and initializing variables       loops       arrays       strings       functions       libraries and #include statements       #define statements           This environment allows one to provide logic and functionality to their circuit connected to the Arduino Nano. After writing a program in the IDE, the program can then be compiled and uploaded to the Arduino board from the IDE itself.   The Arduino IDE Coding Structure      The coding structure for a typical Arduino program:            #define  &lt;pin#&gt;                    This allows one to refer to the variableName instead of the pin# so that it is easier to read and if the pin# changes, you would only need to change the pin# in the define statement rather than in the entire program.                       setup()                    Runs once           Define your pins to be an INPUT or OUTPUT pin           Set the serial baud rate and allow you to use Serial.print()                       loop()                    Runs forever, like a forever for loop           Read inputs from pins or output to a pin                           Typical Arduino Functions      digitalWrite(pin #, HIGH/LOW)            outputs discrete voltage (HIGH/LOW)           analogRead(pin #)            reads variable voltage (outputs a range from 0-1023)           delay(milliseconds)            pauses for a specified time           Serial.print(text)            prints out text to the serial window           Serial.println(text)            same as above, but adds a new line afterward           Note: Make sure you call Serial.begin(9600) in setup() or this won’t work!   Project Specification Part 1 (Building the Schematic on your Breadboard)   There are two parts to the schematic below. On the left side, you can see the potentiometer symbol with the two OUTER terminals connected to GND and 5V(could also use Vin) and the middle terminal connected to an analog input pin (A4). MAKE SURE THE MIDDLE TERMINAL IS NOT CONNECTED TO EITHER 5   On the right side, you can see the LED circuit consisting of an LED and resistor in series (to limit the current going through the LED). The resistor R1 is connected to the digital pin D7 which you will program in the Arduino IDE to output 5V(turn on the LED) or 0V(turn off the LED).          Project Specification Part 2 (Writing the Arduino Program)      Using the coding structure mentioned before and the pseudocode below, program the LED to turn on/off for a certain amount of time based on the value from the potentiometer. Some useful functions include:            pinMode(, &lt;INPUT/OUTPUT&gt;);       Serial.begin(9600);       Serial.print(“Some statement to print to the serial monitor on your laptop”);       digitalWrite(, &lt;HIGH/LOW&gt;);       analogRead()       delay(&lt;# of milliseconds&gt;)                    Note: there are 1000 milliseconds in 1 second                                  Checkoff Questions   Here are some questions you can use to test understanding of the concepts involved in this project:      What is the difference between a digital and an analog signal?      Digital: either LOW or HIGH (OFF or ON, square wave);   Analog: Has a lot of possible values (0-255) making any transition smooth and continuous; emulated by PWM (they must answer this last part too)      When do the setup and loop functions run, and what do they do?      Setup function runs once when the Arduino turns on, then the loop function runs repeatedly every clock cycle, indefinitely      How does a voltage divider work?      When two resistors are in series with each other and connected to a voltage source, the voltage across each resistor is split in proportion to their resistance values.  ","categories": [],
        "tags": [],
        "url": "/projects/4-microcontrollers/",
        "teaser": "/assets/images/arduino.jpg"
      },{
        "title": "5: Digital, Analog, and PWM",
        "excerpt":"       About this Project   In this project, you will be making an iPod Arduino Music Player. It will contain 3 subsystems: a speaker that plays programmable music of your choice, a potentiometer interface that allows users to select 1 of 3 songs, and a display (which you design!) that indicates which song will play.   Lecture Slides   Prerequisites      4: Microcontrollers   Skills Learned      Digital/Analog signals   Pulse Width Modulation (PWM)   Intermediate Arduino programming   Using library files   Parts List                  Part       Quantity       Estimated Cost       Example Vendor                       Arduino Nano       1       $4.00       Amazon                 Mini USB Cable       1       $1.80       Mouser                 Breadboard       1       $1.50       Amazon                 Speaker       1       $0.85       Digikey                 Potentiometer       1       $1.00       Adafruit                 82 Ohm Resistor (for Speaker)       2       $0.03       Digikey           In addition to the listed parts, you’ll also want to order assorted LEDs and resistors so that members can implement their own display designs.      Note: The listed speakers do NOT come pre-soldered. You will need access to a soldering station to solder the two leads yourself.    Total estimated cost: $9.21 per member + assorted parts for display If reusing Arduino/MiniUSB/Breadboard: $1.91 per member + assorted parts for display   Project Specification   In order build our own iPoduino and program a song of our choice on it, we will develop it subsystem by subsystem. But first, we will build a quick demo to demonstrate the magic of PWM!   Checkpoint 1: Manually Create PWM   Before we start creating our iPod, let’s test your understanding of PWM.   A quick recap: our Arduino Nano is not capable of producing true analog signals. Rather, it is only capable of producing digital outputs (either HIGH or LOW, nothing in between). However, by rapidly alternating between HIGH and LOW for a particular proportion of time (duty cycle), we can simulate an analog voltage!          As seen in the above figure, a duty cycle of 50% means that the signal is HIGH half the time and LOW half the time. This equations to an analog voltage value that is 50% of HIGH. By varying the duty cycle, we can also vary the resulting analog output. This is in fact what happens every time we call the analogWrite(int x) function: the integer parameter x gets mapped to a duty cycle!   Now onto the assignment: You will need to control the brightness of an LED by generating a 1 kHz PWM square wave (1 kHz corresponds to one wave every 1000 microseconds). Think about what parameters you can change that will correspond to a change in the LED’s brightness.   You’ll be restricted to using only two functions in your loop():      digitalWrite(pin#)   delayMicroseconds(#us)   To get checked off: create 3 different Arduino sketches, with each one clearly corresponding to a different brightness level.   Checkpoint 2: Sound Check   It’s time to build our iPoduino! The schematic is shown below for convenience. Note that the display interface that tells the user which song will play is not shown (since you’ll design it yourself!).          For the first part of the project, you will be programming your own song to play through a speaker. To do this, there are a few helpful Arduino functions:      tone(pin, frequency): generates a 50% duty cycle PWM square wave at specified frequency.   noTone(pin): stops PWM wave generated by tone()   However, we’ve simplified the use of the two functions above for you by writing the following helper function, play():          Copy this code into the top of your program, putting your speaker output pin in the indicated field. This function takes a note frequency and its duration as input, and sends a PWM signal to the output pin aliased as SPEAKER.   Please also download one of the following files and place it in the same folder as your Arduino iPod sketch:      pitches.h - includes all notes   basicpitches.h - includes only one octave for simplicity’s sake   In your main Arduino iPod sketch, write #include “pitches.h” at the top of your program. These files include note frequencies (in Hz) represented by their common note name (e.g. 262Hz can now be called as NOTE_C4, with 4 indicating the octave number).   Now, you will be able to play notes in the following format:      play(NOTE_C4, 4) —&gt; play middle C for 4 note durations   an n-beat rest can be programmed using delay(NOTE_DUR*n)   By making repeated calls to play(), we can play songs through our speaker!   To get checked off: write a song (minimum 10 notes) and play it through your speaker. The song should play on start-up and when the reset button in the center of the Arduino is pressed. We encourage you to get creative and show us something cool! E-mail us at outreach@ieeebruins.com! :)   For some inspiration: Despacito.h. Copy and paste into your code and call Despacito() to see it go!   Checkpoint 3: Interface   For the next portion of the project, you will be implementing a potentiometer interface. Depending on what voltage is read from the potentiometer when the reset button is pressed, you will need to be able to switch between at least 3 songs. This means you’ll have to program more songs! Pseudocode for this portion is pictured below:          It might be helpful to create a separate function for each programmed song, to make your code more organized. Additionally, think about this: if a song is only being played when the reset button is pressed, where in our Arduino code should the songs be played?   To get checked off: be able to play 3 different songs by turning the Potentiometer dial and pressing the reset button.   Checkpoint 4: Display   Alright, at this point you’ve accomplished quite a bit! You’ve programmed at least 3 songs, and can switch between them by turning your potentiometer dial and pressing the on-board reset button. However, which potentiometer settings correspond to which songs is a bit of a guessing game, since we don’t have real-time feedback until the button is already pressed.   Much like a real iPod has a visual display indicating which song we are selecting, we’ll add a display to our iPoduino! Once your iPoduino is done playing music, it should indicate which song will play next when the reset button is pressed again. When your iPoduino is playing music, it need not display anything. It’s up to you to implement this, as there are multiple ways of going about this. For example, we could represent different songs with different colors, different brightnesses, etc.   To get checked off and complete your iPoduino: demo your fully functional Arduino iPod with the display system you designed.   Further Understanding   Think about each of our 3 subsystems: sound, interface, and display. Which of these utilizes Analog/Digital inputs and outputs? Which of these utilizes PWM signals?   Member Examples   Some past OPS members have made some pretty dope iPoduinos! Turns out there are a ton of music nerds in engineering. Check out some standout projects below:                 Send us yours for a chance to be featured too :-)   Checkoff Questions   Here are some questions you can use to test understanding of the concepts involved in Checkpoint #1 (manually creating PWM):      How did you ensure that your PWM signal has a frequency of 1 KHz?      1 KHz corresponds to a period of 1000 microseconds, so the amount of time that the LED is on AND off should add up to 1000 microseconds.      Why does our frequency need to be so high? Why can’t we just use the regular delay() function instead of delayMicroseconds()?      The frequency needs to be high enough so that our eyes can perceive the blinking as a brightness. If we used delay() instead, we would get different blinking rates but not different brightnesses.  ","categories": [],
        "tags": [],
        "url": "/projects/5-digital-analog-pwm/",
        "teaser": "/assets/images/iPoduino.png"
      },{
        "title": "6: Transistors",
        "excerpt":"       About this Project   In this project, you will be making a distance sensor using a phototransistor (IR receiver), IR emitter, and an LED whose brightness will be adjusted based on how long the distance is from an object to the IR receiver and IR emitter pair.   Lecture Slides   Prerequisites      4: Microcontrollers   Skills Learned      Intermediate Arduino programming   Sensors   Transistors   Parts List                  Part       Quantity       Estimated Cost       Example Vendor                       Arduino Nano       1       $4.00       Amazon                 Mini USB Cable       1       $1.80       Mouser                 Breadboard       1       $1.50       Amazon                 LED       1       $0.25       Digikey                 IR Receivers (Phototransistors)       1       $0.27       Digikey                 IR Emitters (IR LEDs)       1       $0.60       Pololu                 130 Ohm Resistor (for LEDs)       2       $0.03       Digikey                 10k Ohm Resistor (for IR Receiver)       1       $0.03       Digikey           Total estimated cost: $8.66 per member If reusing Arduino/MiniUSB/Breadboard: $1.36 per member   Project Specification   The basis of this project is the interaction between two interesting and useful electronic components:      An Infrared (IR) light emitting LED. Looks like a black LED.   An IR phototransistor, or IR receiver. Looks like a clear LED (don’t mix them up!) We will place these two components next to each other so that when an object is within a close enough proximity, IR light is reflected from the IR LED into the IR receiver.   This can be seen in the image below:          By designing our Arduino circuit properly, we’ll be able to tell when an object is in front of our Distance Sensor!   Checkpoint 1: Reading IR Values   Schematic:          Your first task is to build the schematic shown above on your breadboard. In order to power the circuit, we’ll be using a mini USB cable to provide power to our Arduino. Essentially, the IR Receiver acts as a variable resistor. When no IR light is sensed, it can be thought of as having a very high resistance. When a lot of IR light is sensed, it can be thought of as having a very low resistance. Since we are reading the voltage at the meeting point of the 10k Ohm Resistor and the IR receiver, we have essentially built a voltage divider! If we read the voltage at pin A4 with no object present, it will be near 0V. If we read it with an object present, it will be near 3.7V. We’ll use this to our advantage later.   In order to get best results, make sure your IR LED and IR Receiver are located as close as possible to each other. Another thing to be wary of is the polarity of these various components, as they differ from regular LEDs. A summary is listed below:                  Type       Positive(+)       Negative(-)                       LED       Longer Lead Round Edge       Shorter Lead Flat Edge                 IR Receiver/Phototransistor       Shorter Edge Flat Edge       Longer Lead Round Edge                 IR Emitter/LED       Shorter Lead Round Edge       Longer Lead Flat Edge           For the programming portion of this checkpoint, you will need to print out the value read by the IR Receiver to the serial monitor. As the object gets closer, the value that is read should increase.   Checkpoint 2: Noise Calibration and LED Output   By nature of the way we have set up our IR pair, there is noise, ambient IR light that is picked up despite no object being present. In order to account for this, we would like to get a new “zero” value by taking the average background value from our IR Receiver over 100 samples.   An example code snippet is provided below:   #define IR 17 long zero = 0;  void setup() {   // put your setup code here, to run once:   pinMode(IR, INPUT);   for (int i = 0; i &lt; 100; i++) {     zero += analogRead(IR);   }   zero /= 100; }   With this in mind, here are the main steps involved in our Arduino program:      First we read the raw IR receiver reading using analogRead()   Then we need to constrain this value to our new calibrated range. Our noise-adjusted “zero” value is our new minimum value. The high value will likely be around 1023, but should be adjusted for best results. The constrain() function will come in handy here.   int new_reading = constrain(x, a, b);   This will return:      x if a &lt; x &lt; b   a if x &lt; a   b if x &gt; b      Finally, we will use the new constrained input reading to change our output LED brightness. When an object gets closer, we want the brightness to increase. However, analogWrite() takes a value from 0-255 while analogRead() returns a value from 0-1023. We’ll need to use the map() function to scale this down!   mapped_value = map(raw_val, initial_min, initial_max, final_min, final_max);   This returns raw_val scaled from the initial range to the final range.   Example: Map val from 0-1023 to 0-255   void loop() {   int val = analogRead(0);   val = map(val, 0, 1023, 0, 255);   analogWrite(9, val); }   Final Pseudocode   // define the pins  // for calibration long zero = 0;  void setup() {   // Set the Serial baud rate   // Set the pin modes   // Set the variable zero to the average of 100 samples }  void loop() {   // 0 is no IR light, 1023 is max IR light being reflected   // Step 1: Read IR Reading   // Step 2: Constrain the raw IR reading from \"zero\"-1023   // Step 3: Map the reading to an output value, from \"zero\"-1023 to 0-255   // Step 4: Adjust brightness of LED based on new mapped reading }   Project Completion: Show your fully functioning Distance Sensor, where the LED’s brightness smoothly scales from zero to full brightness as an object gets closer.   Checkpoint 3: Soldering   In order to solder this project, you will need a perfboard, female headers, and a soldering station in addition to the parts listed in the Parts List section.   Notes:      Don’t solder your Arduino directly to the perfboard! Use female headers instead, allowing us to insert and remove our Arduino.   Checkoff Questions   Here are some questions you can use to test understanding of the concepts involved in the Distance Sensor project:      What are the three terminals of a transistor called, and which one does the phototransistor use to take in light?   Why should you keep the emitter and receiver close together?   What are the parameters to the map function and what does it do with them?   Why do we need to sample 100 IR values in setup()?  ","categories": [],
        "tags": [],
        "url": "/projects/6-transistors/",
        "teaser": "/assets/images/DistanceSensor.png"
      },{
        "title": "7: Serial Communication",
        "excerpt":"       About this Project   In this project, you will be implementing a 2-Arduino game called Red Light, Green Light. In this game you are a carduino playing against a randomly generated stoplight: You must move at a green light, and stop at a red light; should you run over a red signal, or stay put at a green signal, you lose. If you get it right, you’ll gain a point and move to the next intersection.   Lecture Slides   Prerequisites      4: Microcontrollers   5: Digital, Analog, and PWM   Skills Learned      Pull-up/pull-down resistor   Serial protocol: UART (Universal Asynchronous Receiver Transmitter)   Parts List                  Part       Quantity       Unit Cost       Example Vendor                       Arduino Nano       1       $4.00       Amazon                 Mini USB Cable       1       $1.80       Mouser                 Breadboard       1       $1.50       Amazon                 Green LED       1       $0.12       Digikey                 Red LED       1       $0.14       DigiKey                 White LED       1       $0.17       DigiKey                 HC-05 Bluetooth Module       1       $10.39       Amazon                 Push Button       1       $0.23       DigiKey                 10k Ohm Resistor       1       $0.10       DigiKey                 100 nF (0.1 uf) Capacitor       1       $0.49       Digikey                 200 Ohm Resistor       6       $0.10       DigiKey                 Speaker       1       $0.90       Digikey                 Potentiometer       1       $0.95       Adafruit           Total estimated cost: $TODO per team of 2   If reusing Arduino/MiniUSB/Breadboard: $TODO per team of 2   Project Specification   One microcontroller (representing the stoplight) will flash one of the two red/green LEDs and the other microcontroller (representing the Car and its gas/brake pedals) will have two tactile switches (fancy word for buttons). Press the gas at green lights and the brake at red lights in order to score points and move to the next intersection. Get it wrong and you lose!   The goal of this project is to teach you how to use Serial communication and give you your first experience with communication protocols before we move on to more sophisticated and complex protocols.   Reference Material   This lab requires reading documentation and datasheets. Here are some resources that you will reference throughout the project.      Lecture 7 Slides   Arduino Nano DataSheet   Arduino Nano Pinout   Arduino Serial Library   Arduino random() Function   Processing Language Reference   HC05 Connection Tutorial   Checkpoint 1: Getting UART Working   This is a group project! Team up with a partner!           Wire up your MCU to your HC-05 so we can get them talking using the Serial library. To read and write between hardware devices, use the Serial library’s read and write functions. Also, make sure that you are first checking that there is available serial data before reading from Serial. To print text to your Processing screen on your computer use the print or println functions as we have done before. Remember that data transmitted by one MCU is data received by the HC-05. Connect the Tx of one device to the Rx of the other device and vice versa. Make sure you also connect GND pins on both devices to each other so they share a common ground.              NOTE: DO NOT CONNECT THE TX RX PINS WHEN UPLOADING A SKETCH TO YOUR ARDUINO. Disconnect these pins when uploading code and reconnect them after the code is done uploading.                 Write two sketches, one for the Arduino, and one for Processing:                       The Arduino sketch should accomplish the following:                                   Check for the hardware button press, if it was pressed then set the point value to zero.                              This is done so we don’t have to reset the Arduino module if we want to replay (and thus don’t have to reconnect over bluetooth)                                                Randomly generate a color for the stoplight intersection 2. Can be done using characters such as ‘r’ or ‘g’ to signify ‘red’ and ‘green’ respectively                              Can also be done using integers such as ‘1’ or ‘0’.                                                Light the appropriate LED using the randomly generated item from before                              I.E. if the char was ‘r’ light the red LED                                                Read from the Serial buffer if there is data available                                               Make sure to implement a wait to read which can be done with:                                                           While Serial.available == 0 {}                                              Do nothing loop (just waits until there is data)                                                                                Some type of software identifier                                                                                    Use Serial.read() to log the data from bluetooth                                                                Identify whether or not the move sent over bluetooth was the correct move. This portion must meet the following requirements:                                               IF CORRECT:                                                           One point must be added to the scoreboard                                                            A “happy tone” must be played from the buzzer for half a second                                                                       Choose some arbitrary high pitch                                                                        You’ll likely want to include pitches.h                                                                                                        Have the white LED flash once per the number of points                                              If 10 points there should be 10 flashes                                                                                                        IF INCORRECT:                                                           Points must go back to 0                                                            The Red LED must turn on for 5 seconds                                              While it is on a “mad tone” must be played from the buzzer for an equal amount of time                                                                                                                        The number of points should be printed back across serial communications to the host device                              Use Serial.println()                                                        The Processing Sketch should accomplish the following:                                   Have two digital buttons                                               One for GO                                      Must be green                                                                One for STOP                                      Must be red                                                                Buttons must be functional and send data across bluetooth to HC05 for MCU processing                                                                Display the point count at the bottom of the screen                                    The majority of this code will be given to you, with comments describing the general UI functionality. It is not a requirement of this game for you to make a beautiful UI, but it is a requirement for it to be functional. Feel free to alter the looks however you like once the functionality is working                                       Checkpoint 2: Wiring Up Hardware   Creating the green and red lights: You will need to hook up 2 different output LEDs to your Stoplight Arduino. Remember, LEDs can burn out if more than 20mA of current passes through them, and usually you want to limit current to &lt;=5mA to save energy and to prevent the LED from being too bright. Make sure to include a current-limiting resistor in series with your LEDs. The digital pins output ~5V when you write HIGH.   Points reset: Your RC-carduino will have 1 push button input that represents the points reset. If the button is pressed the number of points should return to their default state of zero.   NOTE: Button Debouncing.   When you press or release a button, it will “bounce” several times before reaching its final state, which means several button presses will be registered.      One way to avoid this is to put a capacitor in series with the button, so that the button release will not register until after the capacitor is fully discharged over time. If the capacitor’s value has been appropriately chosen, this will be after the button has finished bouncing, such that only one press will be registered. Below is the basic circuit for button debouncing:      Vout is the voltage read by the microcontroller input pin, and Vdd is +5V. Use a 10k resistor and a 100nF capacitor for your debouncing circuit, so that you achieve an RC time constant of 1ms (time constant = resistance * capacitance).   NOTE: This debouncing circuit also includes a pull-down resistor, so that Vout is HIGH when the button is pressed, and LOW otherwise. Also, the RC constant can be a complicated topic, but for now it is sufficient to understand that it is the product of resistance and capacitance, and corresponds to the amount of time the circuit debounces.           Draw the full schematic (on paper). After you get checked off, continue onto..            Write a sketch and build the circuit to light up each LED on one Arduino while its corresponding button on the other is pressed down. When a button is released, the LED should turn off.       Buzzer Scoreboard: Wire a buzzer to a PWM pin on your MCU. When we add a current limiting resistor in series to this buzzer the sound outputted by the speaker should decrease, as the power delivered to the buzzer decreases. We know buzzers can get annoying at times, so because of this you must implement a series potentiometer into your circuit to variably alter the output volume of your speaker.      Game Requirements      Two different colored LEDs (used for stoplight)   One white LED (used for points identification on RC-carduino side)   The Stoplights flashes one of the LEDs; the color chosen should be as random as possible (check the reference materials above for more information);   On Processing IDE (Player Module), the player should press the button that matches the LED the Controller flashed (i.e. Gas for Green Light, Brake for Red Light)   The Stoplight should wait until a button is pressed in Processing (Player Module). The player must press the correct button.   If the player presses the correct button, the white LED must blink the number of points allotted and a point must be added to the player’s score. The buzzer scoreboard should play a high pitched tune briefly. A new round must begin.   Should the player lose (by pressing the incorrect button), the red LED should turn on for 5 seconds, the buzzer scoreboard must play a low tone for the duration of those 5 seconds then start a new game (remember to reset score).   Processing IDE should print the player’s score at the end of every round (intersection). When the play loses, the serial monitor should show this with the reset score after the game starts again.   Project Completion   Implement the Red Light, Green Light game, adhering to the above requirements   Bonus Content   Want to implement your own iteration of this game? Don’t be shy! Use any materials you have at home to add to the game functionality! Or, if you don’t want to alter hardware, don’t be afraid to change up the Processing UI for your RC control interface.   Helpful Tips   Connecting HC-05 to macOS      Turn bluetooth on, then go to bluetooth settings by spotlight searching ‘bluetooth’   Once the HC-05 is powered, you should see it on the list of available devices            Common names are ‘HC-05’ &amp; ‘General’                 Click ‘connect’, then ‘Options’ to enter the passcode, which is 1234 by default. (If 1234 doesn’t work, try 0000)            Now you should be connected to the chip, the red LED on your HC-05 should be blinking. (If not, see Troubleshooting/HC-05 Not Blinking)   Now we’ll locate where the bluetooth port is (you’ll need it later)      Open up Terminal.   Type in the command ls /dev/tty* | grep HC and press enter to locate your bluetooth port. Note it down for future reference.   If this outputs nothing, check that your HC-05 is powered on and blinking.   Now you’re good to go!   Connecting HC-05 to Windows      Navigate to Bluetooth Settings on your PC, go to ‘Add Device’ and add the HC-05 Module   If it asks for a password use ‘1234’ as this is the default password for the module   After it is connected, open up Device Manager on your PC. You can type in ‘Device Manager’ on the Windows Taskbar Search to find it.   Once here, click on Ports and you should see the HC-05 listed as ‘Standard Serial over Bluetooth Link (COMx)’      There may be two ports listed, but only one will work with Processing. We will test later which one, but make note of both of the COM numbers listed. Additionally, if you have anything else connected to your computer, such as your Arduino, you may see it under Ports, this is okay!  ","categories": [],
        "tags": [],
        "url": "/projects/7-serial-communication/",
        "teaser": "/assets/images/RedLightGreenLight.png"
      },{
        "title": "8: Communication Protocols",
        "excerpt":"       Lecture Slides   About this Project   In this project, you will get to design your very own video game console. Using a joystick, OLED display, and a whole lot of code you will get to create your very own GameBuino and video game to play with it! This project is fairly complex, we highly encourage you to start early and ask questions when you need help.   Prerequisites      7: Serial Communication   Parts List                  Part       Quantity       Estimated Cost       Example Vendor                       OLED Display       1       $14.99 (pack of 5)       Amazon                 Joystick       1       $13.29 (pack of 10)       Amazon                 Breadboard       1       $12.08 (pack of 6)       Amazon                 Jumper Wires       10       $6.98 (pack of 120)       Amazon                 Arduino Nano       1       $19.99 (pack of 3)       Amazon              Optional: pushbuttons, buzzers, leds   Total estimated cost: $13.59 per team of 2   Part 1: Designing your Gamebuino   The first part of the GameBuino project is to set up the hardware portion, both wiring and testing it. For the checkoff, you only need to have the Joystick and OLED Display, but we encourage you to think about what parts you might want to add to your console for the competition, like a buzzer for game music, an LED for special effects, or buttons for additional controls! Be creative, we can’t wait to see what you come up with.   Section 1: Wiring   To start with the hardware, we first need to wire both the OLED display and joystick.   The OLED display uses i2c communication protocol, meaning that it uses two pins for communication, Serial Data (SDA) and Serial Clock (SCL). On Arduino Nano, the pin A4 is used for SDA, and pin A5 is used for SCL.   The joystick has three pins for measuring input: VRX, VRY, and SW. VRX tracks the joystick position on the X axis, VRY tracks the joystick position on the Y axis, and SW tracks the built in joystick button. You can use male-to-female jumper wires to wire the Joystick and then tape it down securely, if you can’t find male-to-female you can always use female-female and male-male together.   Optionally: You can also wire any other components you would like to use in your game console, like buttons, LED’s, or a piezo buzzer.          Wiring              OLED Display        Joystick              GND        Ground        GND        Ground              VCC        5v        +5V        5v              SDA        A4        VRX        Any Analog Pin              SCL        A5        VRY        Any Analog Pin                              SW        Any Digital Pin          Schematic      TIPS:      If you have having trouble with this, try wiring and testing each part separately instead of doing both at the same time   Make sure you have no open circuits.   Section 2: Your Joystick   Next, we need to calibrate the joystick and ensure that it works for our game. This will require writing some software to check what values your joystick changes on. The idea behind this is to write code to output the values of the X axis, Y axis, and Switch so that you can see how they change when you move the joystick.   Here is some pseudo code to get you started:   Declare your pins for VRX, VRY, and SW  SETUP:     Start the Serial Monitor     Initialize Pin Modes  LOOP:     Read the analog values of VRX and VRY     Read the digital value of SW     Serial.print(\"X: \");     Serial.print(vrxValue);     Serial.print(\"\\t\"); //this prints a tab     Serial.print(\"Y: \");     Serial.print(vryValue);     Serial.print(\"\\t\"); //this prints a tab     Serial.print(\"SW: \");     Serial.println(swValue);   Note: to initialize the SW pin mode, you’ll want to use INPUT_PULLUP for the mode, as that is what the joystick is designed for.   Next you’ll want to run this code and write down values you’ll want to use for comparison. Find out what value the joystick outputs when you hold it up, left, right, and down, and write them down. You might also want to write down what values are outputted when the joystick is in it’s “DeadZone”, which is when you’re not moving it all. Finally, write down what value you get for the Switch when you press down on the joystick, you will be using this as the button in your game.   Now that you have those values, write some more code to simulate how the game will react to joystick input. The code should write “UP” to serial monitor when you are hold the joystick up, “DOWN” when you hold it down, “LEFT” when you hold it left, “RIGHT” when you hold it right, and “BUTTON PRESSED” when you press the button.   Here is some pseudocode to get you started:   Declare your pins for VRX, VRY, and SW  SETUP:     Start the Serial Monitor     Initialize Pin Modes  LOOP:     Read the analog values of VRX and VRY     Read the digital value of SW     IF joystick is up:         print \"UP\"     IF joystick is down:         print \"DOWN\"     IF joystick is left:         print \"LEFT\"     IF joystick is right:         print \"RIGHT\"     IF joystick button is pressed:         print \"BUTTON PRESSED\"   *Note: How do you tell if joystick is being held in a certain direction? Compare the threshold values you found with the previous code, for example, if VRY is 1023 when you hold it up, and 550 at the center, maybe check if VRY&gt;900 for the comparison.   Section 3: OLED   Now that we have our Joystick working, let’s make sure that our OLED Display works! This is a beautiful display that we can control really closely, you can set each individual pixel! To make sure that it works, we’re going to need to download Arduino libraries and then run a code example designed for our OLED.      Install the Arduino libraries “Adafruit GFX Library” and “Adafruit SSD1306 Library”. To do this first, open the Arduino IDE and make a new sketch. Then click on the bar at the top that says Tools, then click Manage Libraries. Tools&gt;Manage Libraries. A popup should come up that says Library Manager.         Next, search for Adafruit GFX and click install.         Next, search for Adafruit SSD1306 and click install.         Next, go to Files&gt;Examples&gt;AdafruitSSD1306&gt;ssd1306_128x64_i2c. This should open up the example code sketch.         Next, edit the sketch to change OLED_RESET to -1 and SCREEN_ADDRESS to 0x3C. It says that Ox3C is only used for 128x32, however our OLED’s are made by a different manufacturer that uses Ox3C for 128x64.    →              Next, save the edited file, it will require you to name it something since you can’t edit the actual example file.            Finally, upload the software to your Arduino Nano and you should see animation happening on the screen! If you don’t see anything, double check that you wired it correctly.             Congratulations, you’re done with the hardware portion of your GameBuino, now onto coding the actual game!   Part 2: Software   Now that we have our hardware ready, let’s program our very own game! For the purposes of checkoffs, you will be programming a simple game of TicTacToe. If you missed the lecture, make sure you read the slides to learn about arrays and functions which you will need for this project.   Section 1: Graphics   Since the adafruit graphics library can be complicated and tedious, we have provided you with a TicTacToe graphics display library for you to use which will do most of the hard work for you. (for those who want to try coding graphics themselves, don’t worry, more information on that will be provided in the competition section). Follow these steps below to download and use the TicTacToe graphics library.      Read over the libraries github README for usage information. Github is a very popular tool for software version control and collaboration, so you might want to spend some time getting used to the website. Here is the link to the TicTacToe graphics library github: https://github.com/PrestonRooker/TicTacToeArduinoOLEDLibrary   Download the library as a zipped folder via the green button that says code, then hit “Download ZIP”. Or you can use this link: https://github.com/PrestonRooker/TicTacToeArduinoOLEDLibrary/archive/refs/heads/main.zip   Next open up a new sketch in the Arduino IDE. Then go to Sketch&gt;Include Library&gt;Add .ZIP Library. Then select the downloaded zipped folder you just downloaded, TicTacToeArduinoOLEDLibrary-main.zip.            Now that you have installed the custom library, you can find the example of how to use it under File&gt;Examples&gt;TicTacToeArduinoOLEDLibrary-main&gt;TicTacToeDisplayExample         From here, read through the example code, and run it on your arduino. Then make a copy of it and try changing things around, and get a general feel for how to use the library.   Finally, start a new sketch for your GameBuino project, and use the graphics library to give graphics to your TicTacToe game! We suggest making it play through a mock game of Tic Tac Toe with just the graphics and code to make sure you understand how you will use it in the final game. If you have any questions or problems with the library don’t be afraid to ask, our discords are always open :)   Section two: controla’ controla’   Now that you’ve coded the graphics for your TicTacToe game, now’s the time to implement the controls. To control your TicTacToe game, you need to code a way for players to take turns, move between square choices, and select the square where they want to place their piece.   Recall how in the hardware portion you wrote code which detected the direction of the joystick and whether it was being pressed. Reuse that code in your controls code so that the player controls the game using the joystick.   For having the player move between squares, you might find it easier to have them only be able to move left or right and then go to the next row down when they reach the end of the current row. Have players use the joystick button to place their piece on the board.   Once you’re done with this, you should have a game where players take turns dropping X’s and O’s onto the TicTacToe board forever.   Section three - victory?   Now that we have the controls of the game done, the final thing to do is to have a way to detect whether or not a player has won. This will be the complicated part of your code, and I definitely suggest making a separate function for it.   Once you’ve made your function which can detect whether or not a player has won, make sure to call it whenever a player finishes their turn by placing a piece, and end the game accordingly if someone has won.   Make sure your function works for all victory conditions in TicTacToe, including vertical victories, horizontal victories, diagonal victories, and ties.   Tips:      It might be easier to use a 1D array to represent your TicTacToe board   If you are having trouble with coding and need more help, definitely reach out to us on discord   Check-offs:   For the checkoff, you should have a functioning game of TicTacToe that can be played with the joystick and displayed on the OLED display. To get checked off you will have to submit a FULL GAME of TicTacToe in your submission form. Click here to submit your project.  ","categories": [],
        "tags": [],
        "url": "/projects/8-communication-protocols/",
        "teaser": "/assets/images/hc05.png"
      },{
        "title": "9: PID and Motor Control",
        "excerpt":"       About this Project   This project will be a culmination of all the skills you have learned in OPS. There are two possible tracks you can go down:      Wall-E: Build a miniature car that follows walls/avoids objects around it   RC Car: Control a car by using the HC-05 and Processing IDE to control it   To do this, you will design your own PCB, and implement a PID controller in software. This project will be more challenging than the previous ones, but the design constraints are more open ended, allowing you to make some design decisions yourself.   Lecture Slides   Prerequisites      7: Serial Communication   Skills Learned      PID Controller   UI/UX Design   Iterative Design   Parts List   Since this project is open ended, different groups will likely use a variety of parts. Many parts, such as breadboards, IR emitters/receivers, or IMUs, can be reused from previous labs. The new parts you will likely need are:                  Part       Quantity       Estimated Cost       Example Vendor                       Ball Caster       1       $2.99       Pololu                 Wheels       2       $7.98       Pololu                 Gear Motors       2       $12.08       Amazon           Total estimated cost assuming part reuse: $23.05 per team of 2   Section 1: Being a Mechanical Engineer   Powering Your Car   Because our final goal is to have a car following some object, we want it to be powered wirelessly through 9V batteries instead of through our computer’s USB port. While we test our vehicle however, the motors require a large amount of power, which would mean we’d need to go through a lot of 9V batteries (not very cost effective). For that reason, when testing and implementing the motors, power the car through your computer. The motors will not go very fast; however, that’s fine for now. When you’re trying to implement later functionalities of the car, you can use the 9V batteries. In the end, your car must be battery powered.   Motors   We will be using the L293D IC to control our motors. The nice thing about the L293D chip is that it has 2 H-bridges, a fantastic circuit to drive motors!      yikes this looks bad!   Thankfully, we’re going to treat this IC like a black box, with each side of the L293D controlling one motor. All we need to know are the inputs and outputs of this device to get it to work properly! (whew!)         Power Supply            pins: 4, 5, 8, 12, 13, 16       VCC1 (pin 16) drives logic levels. You need to connect this pin to 5V on the Nano       VCC2 (pin 8) drives the motors. You need to connect this pin to Vin on the Nano       4, 5, 12, 13 are ground pins                Direction Inputs              pins: 2, 7, 10, 15       IN1, IN2 controls one motor( ie: left motor) IN3, IN4 controls the other (ie. right motor)       connect to any digital pins on the Nano                Directional Logic:                                                  EN               IN1 (IN3)               IN2 (IN4)               Direction                                                               HIGH               LOW               LOW               STOP                                         HIGH               HIGH               HIGH               STOP                                         HIGH               HIGH               LOW               FORWARD*                                         HIGH               LOW               HIGH               BACKWARD*                                         LOW               x               x               COAST**                                                      * these depend on how you set up your circuit and you will need to adjust this           ** setting the EN pin to LOW will let the motor coast to stop, regardless of input at IN1, IN2                           Speed Input            pins: 1, 9       connect to PWM pins on the Nano in order to create variable outputs to motor       note: EN1 denotes the left hand side while EN2 denotes the right hand side of the IC           Output            pins: 3, 6, 11, 14       connect these to the leads of your motor to output what your L293D has done           Tips      L293D has a notch/dot to mark the top of it. Use that to orient your board   Your l293D should go over the middle gap of the breadboard. You don’t want to short circuit your board!   Test the Motors   Don’t forget to pick up a 9V battery connector. It should look like this:      Please note that the motors do not have wires soldered to them already. Which means you’ll have to solder on the wires to the two spots near the front of the motor like so:      *don’t solder jumper wires to this instead, use the solid core BLACK wires on the spool.   Forward/Backward   Once you’ve wired up your motors to the IC, it’s time to do some testing. We’ll first start off with the simple output: moving forward and backwards. We recommend testing one of the motors to make sure it’s wired up correctly and it moves forward/backward with the appropriate logic. Then, mirror the wiring on the other side!   Turns   Turning your wheels is quite simple! In the forward and backward direction, we had the motors moving in the same direction. When we want the car to turn however, what we’ll do is have one motor move forward while the other moves backwards!   Speed   Here is some code to test your motors on different speeds. Notice that we are using PWM signals to generate varying motors speeds! Every motor is slightly different, so make sure to note at what PWM signal your motor starts to turn. This marks the threshold with which your car will/won’t move.   What Makes a Car?   It’s important to plan out your wiring before building your car to ensure that everything fits on it. We recommend color coding as much as you can as well as this will help a lot with debugging! Try to build your car one function at a time. (ie: make sure motors work, then your sensors, etc)   Make sure you put the ball swivel on the bottom of the car along with the motors in order to balance the weight of the car.            Here are some examples of how you can attach your motors.   Your options:   There are two options for your car’s functionality: create a wall following car/a car that follows an object or an RC Car controlled by your computer.   We will be using feedback loops (hint hint, PID controls) in order to control our car and make sure it does exactly what we want it to!           Car Configuration                                    Recommended for cars built with wheels parallel to the long side of the board (limo mode).       The car should also utilize an ‘IR pair’ on the front and sides to detect an upcoming object and/or to follow the wall and turn the car appropriately (think of a roomba moving along the perimeter of a rectangular room).       If following the RC track the IR sensor pair MUST ACKNOWLEDGE objects it’s approaching through a flashing mechanism with LEDs.       We recommend using a variety of LEDs to signal different options to the observer                                Sensors   Regardless of which type of car you choose to implement, you will be using the IR Sensors.   Section 2: PID Control   No matter which mode you choose to implement, the idea of feedback control is the same. You want to use the sensor readings to adjust your output to the motors. This part of the spec will go over the high-level idea and code structure for the two recommended ‘autopilot’ modes (A, B) listed above. Part 3: P(I)D will list a set of steps you might find helpful in tweaking your constants.      Hand-Following   The goal of your PID controller is to maintain some target distance between your car and the hand/object you’re leading it with. Note that using a flat, light-colored object will work better than your hand to get more consistent sensor readings.   For this option, you may assume the two motors are similar enough; the car will go in a relatively straight line if the two motors are set to the same speed. This option only uses one sensor (the ultrasonic sensor). Following the object moving in a not-straight direction is not required, though you can implement it by installing more ‘IR pairs’ (see A Note on IR Pairs).   Here the general idea of how the proportional and derivative term should be used:      Define ‘error’ to be the distance between your car and the object minus the target distance   The proportional term should be used so that the car            speeds up when object is far away       slows down when object is closer       goes backwards when target is too close           The derivative term should be used so that the car changes velocity            faster if error has been increasing       slower if error has been decreasing           Wall/Object-Following   In this project we need to use PID to ensure we do not stray away or into a wall, and instead just travel parallel to it. You may currently be thinking, “Hey, I can just start it parallel to the wall and have it go forward like I already programmed, this project is so easy!” Unfortunately, most cars will not travel in a perfectly straight line due to differences in imperfect motors and uneven weight distributions on the car, plus we are gonna ask to see your final code :).   Now on to how we implement it, we start by deciding the target distance we want the car to be from the wall. This value is up to you, can be determined experimentally, and may not be actually expressed as a distance but instead a target IR reading. Now while the car is moving along the wall you can take (near) continuous readings from the IR and determine the error from the target value. With this error value, and the pid error constants you should adjust the speed of each wheel to correct the path (increasing the speed of the right wheel and decreasing the speed of the left wheel turns the car left; vice-versa for a right turn). Remember the car is moving forward the entire time, but changing its direction according to the error.      The proportional term should be used so that the car            Heads towards the wall when it is too far away       Heads away from the wall when it is too close       The speed at which it heads towards or away from the wall depends on how close or far it is           The derivative term should be used so that the car changes its velocity            Faster if the error is increasing       Slower if the error is decreasing           Once you correctly implement the wall tracking the last (and probably easier) part you have to code is the corner detection. Essentially you will utilize an IR pair to detect an upcoming corner and execute a set of instructions that make your car turn 90 degrees along the corner. These instructions will be independent of and essentially override the PID decisions until it completes the turn. Once it completes the turn it will return to tracking along the new wall. It is up to you the best set of instructions to give your car to make the turn. See A Note on IR Pairs for more details on this part of the project.   Section 3: P(I)D   Tuning the constants for the proportional, (integral), and the derivative term is done by trial-and-error, for the most part. However, there are some things you may want to keep in mind, and some ways to do this more efficiently than randomly hard-coding different numbers and uploading the Arduino code 1000 times.   Before you get started, note the following values:      Minimum PWM duty cycle to make your motor run (min_speed)            This depends on how strong your battery is, you might have to adjust when moving from using USB connection to the battery       You can run something like this code to see when it starts turning           Ranges of raw IR readings            What does it read when there is ‘nothing’ in front of it? (zero)       What does it read when your object is at target distance? (target)       You may find it helpful to map and constrain these values       Here’s an example of how this might be done           The idea is to multiply the raw ‘error’ value by an appropriate constant to be able to map it to analogWrite parameters that minimize the error.      Start by setting all constants to 0   Increase Kp incrementally, until it is responsive but not too jittery            It might be easier to do this step without actually making the motors turn, until the numbers outputted by your controller seems reasonable (between min_speed and 255 and changes as expected)       Use the Serial Monitor!       Once you’re satisfied the numbers you see, check the proportional control with your motors turning, target moving           Repeat #2 for Kd (, Ki)            Remember: start small, observe values before analogWrite’ing them           *The integral constant you settle on may be very small or even 0; this is okay as the integral control is related to accumulated error over time, which is more relevant if the point you are trying to reach changes rapidly. In both projects proportional and derivative control should be sufficient for reaching the target distance, but we still recommend testing this for yourself.   Hints      pulseIn(pin, HIGH/LOW)            We want to measure the elapsed time between a rising edge (LOW to HIGH) and a falling edge (HIGH to LOW) on the echo pin. So the second parameter should be set to HIGH, and the first to the Arduino pin that is connected to the ECHO pin on the HC-SR04.           It is possible that the speed adjustments caused by PID control will want to write out a speed outside of the acceptable range (minspeed-255). You may want to include a line that constrains the possible output to that range.   When deciding how much to change your speed by each control constant should multiply the corresponding error (kp _ error, kd _ derivative of error, ki* integral of error) and then add up the terms which will result in a final sum that influences the change in speed for your wheels.            Finding the derivative and integral of error may not be obvious at first, one function that might help is millis() which returns the amount of time that has passed since the Arduino was reset in milliseconds. If we record the time in each loop and take the difference in successive loops we can find the amount of time elapsed in the previous loop.       With the calculated time we can find the approximate derivative and integral, which will be a good approximation since our time intervals are small (think back to Calc class, average slope and Reimann sum)           Code Outline   A Note on IR Pairs   We will be using the same IR sensor pairs from our distance sensor project for this project. Please note, if you are running into issues with the emitter for any reason, you can actually use a Red LED in replacement because our receivers respond to light in the infrared range.   Again, if you run into issues with your emitter, just replace it with a Red LED and use the same build as you did in the previous project.   Additionally, you should recall the purpose of what you are using the IR pair for in this project when implementing it; you are not changing the brightness of an LED, you are sensing a distance. It will be difficult to implement PID with the pair since the LED and receiver have a limited spectral overlap, so in most cases detecting a threshold analogRead() value from the receiver will be the extent of its use.      In the above circuit the red LED and IR receiver form an IR pair. As the board moves along a wall the IR reading hovers around some value; as the board approaches a corner the pair will approach a wall. As they approach a wall, red light will be reflected back to the receiver and the analog reading will decrease. Once the reading is below a certain threshold (which you can discover experimentally) the board is now too close to the corner and will turn on the blue LED to indicate that it will hit the wall or maybe execute a set of commands that cause it to rotate 90 degrees (hint hint).   FAQ   What orientation do the LED and Phototransistor go in?      For the LED, on the board, the footprint has a flat side to the circle outline. On the LED, there is also a flat side that matches with the footprint. For the phototransistor, you will have to refer to the datasheet and the schematic for your board. On the datasheet, there is a diagram which shows you what the longer and shorter pins are.   What value resistors should I use for R1 and R2 on the IR sensor board?      The resistor connected to the IR LED should be 130 Ohms, and the one connected to the IR Phototransistor should be 10 kOhms. Refer to your Eagle schematic and board design to determine which resistor is which. Remember that SMD Resistors have an orientation while SMD capacitors do not.   How do I attach the motors and ball caster to the breadboard?      The back of the breadboard has an adhesive that the motors and ball caster can be stuck to. You have to remove the paper that is covering the adhesive.  ","categories": [],
        "tags": [],
        "url": "/projects/9-pid-and-motor-control/",
        "teaser": "/assets/images/car-top.png"
      }]
